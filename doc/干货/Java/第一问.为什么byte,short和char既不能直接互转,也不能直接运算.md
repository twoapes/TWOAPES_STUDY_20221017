# 第一问.为什么byte,short和char既不能直接互转,也不能直接运算

```java
import lombok.extern.slf4j.Slf4j;

/**
 * @author add by huyingzhao
 * 2022-06-12 18:34
 * 变量-第一问.为什么byte,short和char既不能直接互转,也不能直接运算
 */
@Slf4j
public class Extend {
    public static void extend() {
        StringBuilder stringBuilder = new StringBuilder("\n");
        byte b1 = 1;
        byte b2 = 2;
        byte b3 = 1 + 2;
        stringBuilder.append(String.valueOf(b3)).append("\n");
//        byte b4=b1+b2;//byte类型+byte类型不能直接转换为byte类型
        //同理
        short s1 = 1;
        short s2 = 2;
        short s3 = 1 + 2;
        stringBuilder.append(String.valueOf(s3)).append("\n");

//        short s4=s1+s2;//short类型+short类型不能直接转换为short类型
        char c1 = '1';
        char c2 = '2';
        char c3 = '1' + '2';//char类型+char类型不能直接转换为char类型
        stringBuilder.append(c3).append("\n");
//        char c4=c1+c2;
        //同理,即便想不同的数据类型也不能直接转换
//        byte b4=b1+s1;
//        short s4=b1+s1;
//        char c4=b1+s1;

//问题来了,为什么byte,short和char既不能直接互转,也不能直接运算?
//其实很简单,自动类型转换时,默认数据类型就是int,因此如果比int范围小的数据类型进行运算和互转时,则必须强制转换成int
//两个方面考虑,一方面可能他们三个的范围本身不大,做运算可能会很容易超出自身的范围,导致数据丢失,而产生意外的值
//第二方面就是日常开发大部分情况中int的范围能够完全满足,根本不需要选范围太小或太大的类型做运算和互转
//因此还不如让byte,short和char不参与自动类型转换,因此在确定运算不会超过范围时,可以使用强制类型转换
        byte b4 = (byte) (b1 + b2);
        short s4 = (short) (s1 + s2);
        char c4 = (char) (c1 + c2);
        stringBuilder.append(b4 + s4 + c4).append("\n");
        log.info(stringBuilder.toString());
    }
}
```
