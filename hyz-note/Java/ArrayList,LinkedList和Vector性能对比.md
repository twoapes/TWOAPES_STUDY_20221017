# ArrayList,LinkedList和Vector性能对比

当涉及到性能比较时，需要考虑多个因素，包括插入/删除操作的效率、随机访问的效率、内存占用以及线程安全性。下面是对`ArrayList`、`LinkedList`和`Vector`这三个常见的`List`实现类在不同方面的性能比较：

1.插入/删除操作的效率：

- `ArrayList`：由于`ArrayList`基于数组实现，它在随机访问时具有良好的性能，但在插入/删除操作时可能比较慢，尤其是在列表的中间位置。插入/删除元素时，需要移动其他元素来调整位置。

- `LinkedList`：`LinkedList`基于链表实现，因此在插入/删除元素时具有较好的性能，尤其是在列表的中间位置。插入/删除元素只需要调整链表中相应节点的引用即可。

- `Vector`：与`ArrayList`类似，`Vector`也是基于数组实现的，因此在插入/删除操作时的性能与`ArrayList`相似。

2.随机访问的效率：

- `ArrayList`：由于`ArrayList`基于数组，通过索引进行随机访问的效率非常高。它可以在O(1)时间复杂度内获取指定位置的元素。

- `LinkedList`：由于`LinkedList`是基于链表，通过索引进行随机访问的效率较低。需要遍历链表直到达到指定索引的位置，因此随机访问的时间复杂度为O(n)。

- `Vector`：与`ArrayList`类似，`Vector`通过索引进行随机访问的效率也非常高，可以在O(1)时间复杂度内获取指定位置的元素。

3.内存占用：

- `ArrayList`和`Vector`：这两个类在内存上的占用是固定的，它们根据元素数量预分配数组空间，可能会导致一些内存浪费。

- `LinkedList`：`LinkedList`在内存上的占用相对较高，因为它需要为每个元素维护一个节点对象，这会导致更多的内存开销。

4.线程安全性：

- `ArrayList`和`LinkedList`：这两个类不是线程安全的，如果在多线程环境下并发修改它们，可能会导致不一致的结果。

- `Vector`：`Vector`是线程安全的，它的方法都被同步化，因此可以在多线程环境下使用。然而，这也导致了一些性能开销。

综上所述，根据具体的使用场景选择适合的实现类。如果需要频繁进行插入/删除操作或需要

当选择List实现类，你可以记住以下口诀：

ArrayList底层数组存，随机访问效率强；
LinkedList底层双向链，插入删除方便当；
Vector线程安全类，虽性能稍显弱，仅用在并发场景。
