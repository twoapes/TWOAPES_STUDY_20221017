# 线程间通讯

在Java中，线程间通信是指不同线程之间通过共享的内存区域来交换信息，以实现协调和同步的机制。Java提供了几种机制来实现线程间通信，其中包括使用共享对象、wait()和notify()方法，以及使用管道、消息队列等。

一种常见的线程间通信机制是使用共享对象作为线程间的交互媒介。多个线程可以同时访问共享对象，通过在对象上加锁来确保线程安全。线程可以通过读取和修改共享对象的状态来传递信息。这种机制需要考虑同步和互斥的问题，以避免数据不一致或竞态条件。

另一种常见的线程间通信机制是使用wait()和notify()方法。wait()方法使线程进入等待状态，直到其他线程调用同一个对象上的notify()方法唤醒它。通过这种机制，线程可以等待某个条件满足后再继续执行，从而实现线程之间的协调。

以下是一个简单的Java线程间通信的示例代码，演示了使用共享对象和wait()、notify()方法来实现线程间的通信：

```java
class SharedObject {
    private boolean flag = false;

    public synchronized void waitForFlag() {
        while (!flag) {
            try {
                wait(); // 线程等待
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("Flag is now true");
    }

    public synchronized void setFlag() {
        flag = true;
        notify(); // 唤醒等待的线程
    }
}

class WaitThread extends Thread {
    private SharedObject sharedObject;

    public WaitThread(SharedObject sharedObject) {
        this.sharedObject = sharedObject;
    }

    public void run() {
        sharedObject.waitForFlag();
    }
}

class SetFlagThread extends Thread {
    private SharedObject sharedObject;

    public SetFlagThread(SharedObject sharedObject) {
        this.sharedObject = sharedObject;
    }

    public void run() {
        try {
            Thread.sleep(2000); // 等待2秒钟
            sharedObject.setFlag();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class ThreadCommunicationDemo {
    public static void main(String[] args) {
        SharedObject sharedObject = new SharedObject();

        WaitThread waitThread = new WaitThread(sharedObject);
        SetFlagThread setFlagThread = new SetFlagThread(sharedObject);

        waitThread.start();
        setFlagThread.start();
    }
}
```

在这个示例中，有两个线程：WaitThread和SetFlagThread。WaitThread在共享对象上调用waitForFlag()方法，如果flag为false，则线程会等待。SetFlagThread在2秒钟后调用setFlag()方法，将flag设置为true，并通过notify()方法唤醒等待的线程。当WaitThread被唤醒后，它将输出"Flag is now true"。

这个示例展示了如何使用共享对象和wait()、notify()方法来实现线程间的通信和协调。注意到共享对象的关键方法都使用了`synchronized`关键字来保证线程安全，避免并发访问的问题。

当涉及到线程间的同步和通信时，除了使用`synchronized`关键字、`wait()`和`notify()`方法外，还可以使用`Lock`和`Condition`接口来实现线程间的通信和协调。`Lock`提供了更灵活的锁定机制，并且`Condition`提供了类似于`wait()`和`notify()`方法的功能。

下面是一个使用`Lock`和`Condition`实现线程间通信的示例代码：

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SharedObject {
    private boolean flag = false;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void waitForFlag() {
        lock.lock();
        try {
            while (!flag) {
                try {
                    condition.await(); // 线程等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("Flag is now true");
        } finally {
            lock.unlock();
        }
    }

    public void setFlag() {
        lock.lock();
        try {
            flag = true;
            condition.signal(); // 唤醒等待的线程
        } finally {
            lock.unlock();
        }
    }
}

class WaitThread extends Thread {
    private SharedObject sharedObject;

    public WaitThread(SharedObject sharedObject) {
        this.sharedObject = sharedObject;
    }

    public void run() {
        sharedObject.waitForFlag();
    }
}

class SetFlagThread extends Thread {
    private SharedObject sharedObject;

    public SetFlagThread(SharedObject sharedObject) {
        this.sharedObject = sharedObject;
    }

    public void run() {
        try {
            Thread.sleep(2000); // 等待2秒钟
            sharedObject.setFlag();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class ThreadCommunicationDemo {
    public static void main(String[] args) {
        SharedObject sharedObject = new SharedObject();

        WaitThread waitThread = new WaitThread(sharedObject);
        SetFlagThread setFlagThread = new SetFlagThread(sharedObject);

        waitThread.start();
        setFlagThread.start();
    }
}
```

在这个示例中，`SharedObject`类使用了`Lock`和`Condition`来实现线程间的通信。`Lock`通过`ReentrantLock`实例化，`Condition`通过`lock.newCondition()`创建。`waitForFlag()`方法使用`condition.await()`来等待条件满足，而`setFlag()`方法使用`condition.signal()`来唤醒等待的线程。

`Lock`和`Condition`提供了更高级的同步和通信机制，相对于`synchronized`和`wait()`/`notify()`来说更加灵活和可控。它们可以在更复杂的多线程场景中使用，并且可以更细粒度地控制线程的行为。
