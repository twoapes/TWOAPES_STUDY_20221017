# 集合线程安全异常

下面是一个演示集合线程安全异常的简单示例代码：

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class ThreadSafetyDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        // 创建一个线程安全的包装集合
        List<String> synchronizedList = Collections.synchronizedList(list);

        // 创建两个线程并发修改集合
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    synchronizedList.add("Thread 1");
                }
            }
        });

        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    synchronizedList.add("Thread 2");
                }
            }
        });

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("List size: " + synchronizedList.size());
    }
}
```

在这个示例中，我们创建了一个 `ArrayList` 对象 `list`，然后使用 `Collections.synchronizedList()` 方法创建了一个线程安全的包装集合 `synchronizedList`。

接下来，我们创建了两个线程 `thread1` 和 `thread2`，它们并发地向 `synchronizedList` 中添加元素。

由于 `synchronizedList` 是一个线程安全的集合，它在内部使用了同步机制来保证多线程操作的正确性。因此，即使多个线程同时修改集合，也不会发生异常。

最后，我们使用 `join()` 方法等待两个线程执行完毕，并打印最终集合的大小。

请注意，线程安全的集合可以确保多线程环境下的数据一致性和线程安全，但在某些情况下可能会降低性能。因此，在选择使用线程安全集合时，应根据具体的需求和并发情况进行评估和选择。
