# 类的加载

类的加载过程是指将类的字节码文件加载到内存中，并创建对应的类对象的过程。在Java中，类的加载过程主要分为以下三个步骤：加载、链接和初始化。

1.加载（Loading）：加载是指将类的字节码文件加载到内存中。当程序需要使用某个类时，Java虚拟机会根据类的名称找到对应的字节码文件，并将其读取到内存中。加载过程通常包括以下几个步骤：

- 类的加载器（ClassLoader）根据类的全限定名（包括包路径和类名）定位字节码文件的位置。

- 类加载器读取字节码文件的内容，并将其转换为内存中的二进制数据形式。

- 类加载器根据这些二进制数据创建一个代表该类的Class对象，并将其存放在方法区（Method Area）中。

2.链接（Linking）：链接是指将类的二进制数据合并到JVM的运行时环境中的过程。链接分为三个阶段：验证、准备和解析。

- 验证（Verification）：验证阶段主要对加载的字节码文件进行合法性验证，确保其符合Java虚拟机规范。

- 准备（Preparation）：准备阶段为类的静态变量分配内存空间，并设置默认初始值。

- 解析（Resolution）：解析阶段将符号引用替换为直接引用，以便能够顺利访问其他类、方法和字段。

3.初始化（Initialization）：初始化是类加载过程的最后一步，也是真正执行类中定义的Java代码的阶段。在初始化阶段，Java虚拟机会按照程序的要求执行类的初始化方法（\<clinit>），该方法由编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而成。初始化阶段是类加载过程中的重要阶段，类的静态变量和静态代码块会按照声明的顺序依次执行，从而完成类的初始化工作。

需要注意的是，类的加载过程是在运行时动态进行的，即当程序运行到需要使用某个类时才会触发加载过程。此外，Java虚拟机对类的加载过程进行了优化，包括类的延迟加载、缓存加载结果等措施，以提高程序的性能和效率。

- 加载

将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）

所有需要访问和使用类数据只能通过这个Class对象

这个加载的过程需要类加载器参与

- 链接

> 将Java类的二进制代码合并到JVM的运行状态之中的过程

- 验证
确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题

- 准备
正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。

- 解析
虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程

- 初始化

执行类构造器\<clinit>()方法的过程

类构造器\<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的

类构造器是构造类信息的，不是构造该类对象的构造器

当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化

虚拟机会保证一个类的\<clinit>()方法在多线程环境中被正确加锁和同步

## ClassLoader的理解

ClassLoader（类加载器）是Java虚拟机（JVM）的一部分，负责将类的字节码文件加载到内存中，并生成对应的Class对象。ClassLoader具有以下几个重要的特点和功能：

1. 类的定位和加载：ClassLoader根据类的全限定名（包括包路径和类名）来定位类的字节码文件，并将其加载到内存中。ClassLoader可以从文件系统、网络、ZIP压缩包等多种来源加载类。

2. 类的命名空间：每个ClassLoader都有自己的命名空间，加载的类和资源只在该命名空间内可见。不同ClassLoader加载的同名类会被视为不同的类。这种机制为实现类的隔离性和安全性提供了基础。

3. 双亲委派模型：ClassLoader采用了双亲委派模型（Parent Delegation Model）。根据这个模型，当一个类加载器接收到加载请求时，它会首先将加载任务委派给其父加载器。父加载器也会按照同样的方式继续委派，直到达到顶层的引导类加载器。只有在父加载器无法加载类时，才会由当前加载器尝试加载。

4. 破坏双亲委派模型：开发者可以通过自定义ClassLoader并重写它的加载逻辑来破坏双亲委派模型。这种机制在某些场景下非常有用，比如实现动态加载和热部署等功能。

5. 动态加载和反射：ClassLoader可以通过调用`loadClass`方法动态加载类，也可以通过反射机制获取已加载类的信息，并动态创建对象、调用方法等。

ClassLoader是Java虚拟机中的一个重要组件，它为Java的类加载机制提供了基础。通过ClassLoader，Java程序可以按需加载类，并在运行时实现类的动态加载和隔离，为Java应用的灵活性和扩展性提供了支持。

类的主动引用

> 一定会发生类的初始化

- 当虚拟机启动，先初始化main方法所在的类

- new一个类的对象

- 调用类的静态成员（除了final常量）和静态方法

- 使用java.lang.reflect包的方法对类进行反射调用

- 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类

类的被动引用

> 不会发生类的初始化

- 当访问一个静态域时，只有真正声明这个域的类才会被初始化

- 当通过子类引用父类的静态变量，不会导致子类初始化

- 通过数组定义类引用，不会触发此类的初始化

- 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）

```java
//1.获取一个系统类加载器
ClassLoader classloader = ClassLoader.getSystemClassLoader();
System.out.println(classloader);
//2.获取系统类加载器的父类加载器，即扩展类加载器
classloader = classloader.getParent();
System.out.println(classloader);
//3.获取扩展类加载器的父类加载器，即引导类加载器
classloader = classloader.getParent();
System.out.println(classloader);
//4.测试当前类由哪个类加载器进行加载
classloader = Class.forName("exer2.ClassloaderDemo").getClassLoader();
System.out.println(classloader);
//5.测试JDK提供的Object类由哪个类加载器加载
classloader =
Class.forName("java.lang.Object").getClassLoader();
System.out.println(classloader);
//*6.关于类加载器的一个主要方法：getResourceAsStream(String str):获取类路
径下的指定文件的输入流
InputStream in = null;
in = this.getClass().getClassLoader().getResourceAsStream("exer2\\test.properties");
System.out.println(in);
```
