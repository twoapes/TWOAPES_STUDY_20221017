# 动态代理

代理设计模式的原理

- 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象

  任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上

- 之前为大家讲解过代理机制的操作，属于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展

  同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理

  最好可以通过一个代理类完成全部的代理功能

- 动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象

- 动态代理使用场合

  调试

  远程方法调用

- 动态代理相比于静态代理的优点

> 抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法

Java反射动态代理是一种在运行时生成代理对象的技术，它允许您通过代理对象来调用目标对象的方法，并在方法调用前后执行额外的逻辑。

动态代理的概念可以简单地描述为：为一个或多个接口动态地生成代理类，代理类中的方法调用会被转发到实际的目标对象上。这种技术在很多框架和库中被广泛应用，例如AOP（面向切面编程）。

Java提供了`java.lang.reflect.Proxy`类和`java.lang.reflect.InvocationHandler`接口来支持动态代理。

以下是使用动态代理的基本步骤：

1. 创建一个实现`InvocationHandler`接口的类，该类负责处理代理对象的方法调用。在`InvocationHandler`的`invoke()`方法中，您可以在调用目标方法之前或之后执行额外的逻辑。

2. 使用`Proxy`类的`newProxyInstance()`方法创建代理对象。该方法接受一个`ClassLoader`对象、一组接口以及一个`InvocationHandler`对象作为参数。

3. 通过代理对象调用目标对象的方法。

下面是一个简单的示例，演示如何使用动态代理：

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Main {
    public static void main(String[] args) {
        // 创建目标对象
        MyInterface targetObject = new MyTarget();

        // 创建代理对象
        MyInterface proxyObject = (MyInterface) Proxy.newProxyInstance(
                targetObject.getClass().getClassLoader(),
                targetObject.getClass().getInterfaces(),
                new MyInvocationHandler(targetObject)
        );

        // 调用代理对象的方法
        proxyObject.myMethod();
    }
}

interface MyInterface {
    void myMethod();
}

class MyTarget implements MyInterface {
    public void myMethod() {
        System.out.println("Target object: myMethod()");
    }
}

class MyInvocationHandler implements InvocationHandler {
    private final Object targetObject;

    public MyInvocationHandler(Object targetObject) {
        this.targetObject = targetObject;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 在调用目标方法之前执行额外的逻辑
        System.out.println("Before method invocation");

        // 调用目标对象的方法
        Object result = method.invoke(targetObject, args);

        // 在调用目标方法之后执行额外的逻辑
        System.out.println("After method invocation");

        return result;
    }
}
```

在上述示例中，我们创建了一个`MyInterface`接口和一个`MyTarget`类作为目标对象。然后，我们实现了`InvocationHandler`接口的`MyInvocationHandler`类来处理代理对象的方法调用。在`invoke()`方法中，我们在调用目标方法之前打印一条消息，并在调用之后打印另一条消息。最后，我们使用`Proxy.newProxyInstance()`方法创建代理对象，并将`MyInvocationHandler`作为参数传递给它。

通过代理对象调用`myMethod()`方法时，额外的逻辑将被执行。

动态代理可以用于很多场景，例如日志记录、事务管理等。它提供了一种灵活的方式来在不修改原始类的情况下添加或修改类的行为。

## 动态代理步骤

使用Java的动态代理，您可以按照以下步骤进行操作：

1. 创建目标接口：定义您希望代理对象实现的接口。

```java
public interface MyInterface {
    void myMethod();
}
```

2.实现InvocationHandler接口：创建一个类来实现`InvocationHandler`接口，并实现`invoke()`方法。在`invoke()`方法中，您可以在调用目标方法之前或之后执行额外的逻辑。

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class MyInvocationHandler implements InvocationHandler {
    private final Object targetObject;

    public MyInvocationHandler(Object targetObject) {
        this.targetObject = targetObject;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 在调用目标方法之前执行额外的逻辑
        System.out.println("Before method invocation");

        // 调用目标对象的方法
        Object result = method.invoke(targetObject, args);

        // 在调用目标方法之后执行额外的逻辑
        System.out.println("After method invocation");

        return result;
    }
}
```

3.创建代理对象：使用`Proxy`类的`newProxyInstance()`方法创建代理对象。该方法接受一个`ClassLoader`对象、一组接口以及一个`InvocationHandler`对象作为参数。

```java
import java.lang.reflect.Proxy;

public class Main {
    public static void main(String[] args) {
        // 创建目标对象
        MyInterface targetObject = new MyTarget();

        // 创建代理对象
        MyInterface proxyObject = (MyInterface) Proxy.newProxyInstance(
                targetObject.getClass().getClassLoader(),
                targetObject.getClass().getInterfaces(),
                new MyInvocationHandler(targetObject)
        );

        // 调用代理对象的方法
        proxyObject.myMethod();
    }
}
```

在上述示例中，我们创建了一个目标接口`MyInterface`和一个实现了该接口的类`MyTarget`作为目标对象。然后，我们实现了`InvocationHandler`接口的`MyInvocationHandler`类来处理代理对象的方法调用。在`invoke()`方法中，我们在调用目标方法之前打印一条消息，并在调用之后打印另一条消息。最后，我们使用`Proxy.newProxyInstance()`方法创建代理对象，并将`MyInvocationHandler`作为参数传递给它。

通过代理对象调用`myMethod()`方法时，额外的逻辑将被执行。

这些是使用Java动态代理的基本步骤。您可以根据具体的需求和场景进行进一步的扩展和定制。

- 使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义

- 通常都是为指定的目标对象生成动态代理

- 这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理包含了目标对象的全部方法

- 但AOP代理中的方法与目标对象的方法存在差异

> AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理
