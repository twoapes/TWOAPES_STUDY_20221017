# 创建线程的方式

JDK1.5之前创建新执行线程

- 继承Thread

- 实现Runnable接口

JDK1.5新增线程创建方式

- 实现Callable接口

- 使用线程池
JVM允许程序运行多个线程，它通过`java.lang.Thread`类来体现

## 特性

- 每个线程都是通过某个特定Thread对象的run()方法来完成操作的
经常把run()方法的主体称为线程体

- 通过该Thread对象的start()方法来启动这个线程，而非直接调用run()

## 构造器

您的解释是正确的，以下是对每个构造函数的进一步解释：

1.`Thread()`: 创建一个新的 `Thread` 对象，该线程对象没有指定名称，也没有指定目标方法。

2.`Thread(String threadname)`: 创建一个新的 `Thread` 对象，指定线程名称为 `threadname`。该线程对象没有指定目标方法。

3.`Thread(Runnable target)`: 创建一个新的 `Thread` 对象，指定线程目标对象为 `target`，该目标对象实现了 `Runnable` 接口中的 `run()` 方法。在启动该线程后，该目标对象的 `run()` 方法将被调用。

4.`Thread(Runnable target, String name)`: 创建一个新的 `Thread` 对象，同时指定线程目标对象为 `target`，线程名称为 `name`。在启动该线程后，该目标对象的 `run()` 方法将被调用。可以通过传递不同的参数来区分不同的线程。

注意，如果指定的线程名称已经被使用，则会自动分配一个新的名称。同时，为了执行线程，必须调用 `start()` 方法，否则线程不会运行。

## 方法

5.`void start()`: 启动线程，并执行该线程对象的 `run()` 方法。注意，线程只能启动一次，如果尝试再次启动同一线程对象，将会抛出 `IllegalThreadStateException` 异常。

6.`void run()`: 在线程被调度时执行的操作。子类必须重写该方法以定义自己的操作。

7.`String getName()`: 返回线程的名称。如果没有设置线程名称，则默认为 `Thread-<n>`（其中 `<n>` 是一个递增的整数）。

8.`void setName(String name)`: 设置该线程的名称。该名称在调试时很有用。

9.`static Thread currentThread()`: 返回当前线程。在 `Thread` 子类中就是 `this`，通常用于主线程和实现了 `Runnable` 接口的类。

10.`static void yield()`: 线程让步，暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程。如果没有同优先级的线程，该方法将被忽略。注意，这种方法不能保证一定会让出 CPU 执行权。

11.`void join()`: 当某个程序执行流中调用其他线程的 `join()` 方法时，调用线程将被阻塞，直到 `join()` 方法加入的线程执行完为止。如果线程在等待时被中断，将抛出 `InterruptedException` 异常。

12.`static void sleep(long millis)`: 令当前线程在指定时间段内放弃对 CPU 控制，使其他线程有机会被执行。时间到后，线程将重新排队。注意，该方法可能会抛出 `InterruptedException` 异常。

13.`void stop()`: 强制线程生命期结束。该方法已经被废弃，不推荐使用。

14.`boolean isAlive()`: 返回 `boolean`，判断线程是否还活着。线程被认为是“活着的”，如果它已经启动并且还没有结束。
