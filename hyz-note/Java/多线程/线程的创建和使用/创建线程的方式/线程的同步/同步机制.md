# 同步机制

Java对于多线程的安全问题提供了专业的解决方式

同步机制

1. 同步代码块

2. 同步方法

1.操作共享数据的代码，即为需要被同步的代码不能包含代码多了，也不能包含代码少了

2.共享数据：多个线程共同操作的变量

比如：ticket就是共享数据

3.同步监视器

俗称：锁,任何一个类的对象，都可以充当锁

要求：多个线程必须要共用同一把锁

- 在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器

- 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器

## 同步锁机制

在《Thinking in Java》中， 是这么说的：对于并发工作， 你需要某种方式来防止两个任务访问相同的资源(其实就是共享资源竞争)

防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁

第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了

## 同步范围

1、如何找问题，即代码是否存在线程安全?(非常重要)
(1)明确哪些代码是多线程运行的代码
(2)明确多个线程是否有共享数据
(3)明确多线程运行代码中是否有多条语句操作共享数据
2、如何解决呢?(非常重要)
对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行
即所有操作共享数据的这些语句都要放在同步范围中
3、切记

- 范围太小

没锁住所有有安全问题的代码

- 范围太大

没发挥多线程的功能

如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。
关于同步方法的总结

  1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。

  2. 非静态的同步方法，同步监视器是：this
静态的同步方法，同步监视器是：当前类本身

## Lock

从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步

同步锁使用Lock对象充当

`java.util.concurrent.locks.Lock`接口是控制多个线程对共享资源进行访问的工具

锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象

ReentrantLock类实现了Lock,它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁,释放锁

如果同步代码有异常， 要将unlock() 写入finally语句块

要在Java中实现锁的示例，可以使用Java的内置锁机制，即`synchronized`关键字或`java.util.concurrent.locks`包中的锁对象。以下是使用`synchronized`和`ReentrantLock`实现锁的示例的详细步骤：

1.使用`synchronized`实现锁的示例：

- 创建一个包含共享资源的类，例如`SharedResource`。

- 在`SharedResource`类中定义一个私有的对象作为锁对象，例如`private Object lock = new Object();`。

- 在需要访问共享资源的方法中，使用`synchronized`关键字修饰方法或代码块。

- 在方法或代码块中，使用锁对象来控制对共享资源的访问，例如：

```java
public void synchronizedMethod() {
    synchronized (lock) {
        // 访问共享资源的代码
    }
}
```

2.使用`ReentrantLock`实现锁的示例：

- 创建一个包含共享资源的类，例如`SharedResource`。

- 在`SharedResource`类中定义一个私有的`ReentrantLock`对象，例如`private ReentrantLock lock = new ReentrantLock();`。

- 在需要访问共享资源的方法中，使用`lock`对象来控制对共享资源的访问，例如：

```java
public void lockMethod() {
    lock.lock();
    try {
        // 访问共享资源的代码
    } finally {
        lock.unlock();
    }
}
```

## synchronized

synchronized的锁是什么?

- 任意对象都可以作为同步锁

- 所有对象都自动含有单一的锁(监视器)

- 同步方法的锁：静态方法(类名.class) 、非静态方法(this)

- 同步代码块：自己指定， 很多时候也是指定为this或类名.class

必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全
一个线程类中的所有静态方法共用同一把锁(类名.class) ， 所有非静态方法共用同一把锁(this) ， 同步代码块(指定需谨慎)

下面是使用`synchronized`关键字实现同步锁的示例的详细步骤：

1. 创建一个包含共享资源的类，例如`SharedResource`。

2. 在`SharedResource`类中定义一个私有的对象作为锁对象，通常命名为`lock`，例如`private Object lock = new Object();`。

3. 在需要访问共享资源的方法中，使用`synchronized`关键字修饰方法或代码块。有两种方式可以实现同步锁：

a. 同步方法：

```java
public synchronized void synchronizedMethod() {
    // 访问共享资源的代码
}
```

b. 同步代码块：

```java
public void synchronizedBlock() {
    synchronized (lock) {
        // 访问共享资源的代码
    }
}
```

4.当一个线程进入了带有`synchronized`关键字修饰的方法或代码块时，它会自动获取锁对象，其他线程在同一时间只能等待，直到该线程释放锁对象。

下面是一个完整的示例：

```java
public class SharedResource {
    private Object lock = new Object();

    public synchronized void synchronizedMethod() {
        // 访问共享资源的代码
    }

    public void synchronizedBlock() {
        synchronized (lock) {
            // 访问共享资源的代码
        }
    }
}
```

在上述示例中，通过`synchronized`关键字修饰了两个方法：`synchronizedMethod()`和`synchronizedBlock()`，用于控制对共享资源的访问。当一个线程进入这些方法时，它会自动获取`lock`对象的锁，其他线程必须等待锁被释放才能继续执行。这样可以确保在同一时间只有一个线程能够访问共享资源，从而保证线程安全性。

## synchronized 与 Lock 的对比

1. Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放

2. Lock只有代码块锁，synchronized有代码块锁和方法锁

3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）

优先使用顺序
Lock →同步代码块（已经进入了方法体，分配了相应资源） →同步方法（在方法体之外）

共同点：

  1. 同步性：`synchronized`和`Lock`都提供了线程同步的机制，用于保护共享资源的访问，确保线程安全性。

  2. 互斥性：它们都能够确保同一时间只有一个线程能够获取锁，并执行被保护的代码块。

  3. 阻塞等待：当一个线程无法获取锁时，它们都可以将线程阻塞，等待锁的释放。

  区别：

4.锁的类型：`synchronized`是Java语言提供的关键字，可以用于修饰方法或代码块，提供隐式的锁。而`Lock`是Java并发包中的接口，提供了显示的锁，通过实例化`Lock`的具体实现类（如`ReentrantLock`）来使用。

5.锁的灵活性：`Lock`相对于`synchronized`更加灵活，提供了更多高级特性。例如，可以实现公平锁或非公平锁、可中断锁、多个条件变量等。

6.代码结构：`synchronized`使用起来相对简单，但只能用于方法或代码块级别的同步。而`Lock`的使用需要显式地调用`lock()`和`unlock()`方法，在使用过程中需要手动确保在适当的时候释放锁。

7.锁的获取方式：`synchronized`在获取锁时是非公平的，无法控制线程获取锁的顺序。而`Lock`可以实现公平锁或非公平锁的方式，可以更加灵活地控制线程获取锁的顺序。

8.性能：在低竞争情况下，`synchronized`的性能可能会比`Lock`更好，因为`synchronized`是由JVM底层实现的，随着JVM的优化，性能逐渐提升。而`Lock`是通过Java并发包提供的，相对而言，会有一些额外的开销。

  综上所述，`synchronized`适用于简单的同步需求，使用起来更为方便，而`Lock`适用于复杂的同步需求，提供了更多灵活性和高级特性。在选择使用哪种锁的时候，需要根据具体的场景和需求来进行选择。
