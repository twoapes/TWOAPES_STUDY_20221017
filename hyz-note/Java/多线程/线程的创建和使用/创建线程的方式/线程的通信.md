# 线程的通信

## wait() 与notify() 和notifyAll()

wait()
令当前线程挂起并放弃CPU、同步资源并等待， 使别的线程可访问并修改共享资源， 而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒， 唤醒后等待重新获得对监视器的所有权后才能继续执行
notify()
唤醒正在排队等待同步资源的线程中优先级最高者结束等待
notifyAll()
唤醒正在排队等待资源的所有线程结束等待

- 这三个方法只有在synchronized方法或synchronized代码块中才能使用， 否则会报java.lang.Illegal Monitor State Exception异常

- 因为这三个方法必须有锁对象调用， 而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明

## wait() 方法

- 在当前线程中调用方法： 对象名.wait()

- 使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。

- 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）

- 调用此方法后，当前线程将释放对象监控权 ，然后进入等待

- 在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。

## notify()/notifyAll()

- 在当前线程中调用方法： 对象名.notify()

- 功能：唤醒等待该对象监控权的一个/所有线程。

- 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）

下面是使用Java实现线程通信的示例代码和详细步骤：

步骤1：创建一个共享对象，用于线程之间的通信。这个对象可以是一个简单的类，其中包含一个共享的变量和对该变量进行操作的方法。

```java
public class SharedObject {
    private int value;
    private boolean isValueSet;

    public synchronized void setValue(int value) {
        while (isValueSet) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        this.value = value;
        isValueSet = true;
        notify();
    }

    public synchronized int getValue() {
        while (!isValueSet) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        isValueSet = false;
        notify();
        return value;
    }
}
```

步骤2：创建生产者线程类，用于设置共享对象中的值。

```java
public class ProducerThread implements Runnable {
    private SharedObject sharedObject;

    public ProducerThread(SharedObject sharedObject) {
        this.sharedObject = sharedObject;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            sharedObject.setValue(i);
            System.out.println("Producer set value: " + i);
        }
    }
}
```

步骤3：创建消费者线程类，用于获取共享对象中的值。

```java
public class ConsumerThread implements Runnable {
    private SharedObject sharedObject;

    public ConsumerThread(SharedObject sharedObject) {
        this.sharedObject = sharedObject;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            int value = sharedObject.getValue();
            System.out.println("Consumer got value: " + value);
        }
    }
}
```

步骤4：在主线程中创建共享对象和生产者、消费者线程，并启动它们。

```java
public class Main {
    public static void main(String[] args) {
        // 创建共享对象
        SharedObject sharedObject = new SharedObject();

        // 创建生产者线程和消费者线程
        ProducerThread producerThread = new ProducerThread(sharedObject);
        ConsumerThread consumerThread = new ConsumerThread(sharedObject);

        // 创建并启动线程
        Thread producer = new Thread(producerThread);
        Thread consumer = new Thread(consumerThread);

        producer.start();
        consumer.start();

        // 等待线程执行完毕
        try {
            producer.join();
            consumer.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

步骤5：运行程序，观察生产者线程和消费者线程之间的通信情况。

当运行这段代码时，生产者线程将会设置共享对象的值，消费者线程将会获取共享对象中的值。生产者线程每次设置值后输出"Producer set value: "，消费者线程每次获取值后输出"Consumer got value: "。

总结：通过创建共享对象，使用synchronized关键字对共享对象的操作进行同步，实现线程之间的通信
