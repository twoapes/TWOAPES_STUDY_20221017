# 线程的分类

Java中的线程分为两类：一种是**守护线程**， 一种是**用户线程**

- 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开

- 守护线程是用来服务用户线程的， 通过在`start()`方法前调用

- `thread.setDaemon(true)` 可以把一个用户线程变成一个守护线程

- Java垃圾回收就是一个典型的守护线程

- 若JVM中者是守护线程， 当前JVM将退出

- 形象理解：兔死狗烹，鸟尽弓藏

下面是使用Java实现守护线程和用户线程的示例代码和详细步骤：

步骤1：创建一个类，实现Runnable接口，并重写run()方法。这个类将作为线程的执行体。

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 守护线程的执行代码
        if (Thread.currentThread().isDaemon()) {
            System.out.println("Daemon thread is running.");
        } else {
            System.out.println("User thread is running.");
        }

        try {
            // 线程睡眠5秒钟
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        if (Thread.currentThread().isDaemon()) {
            System.out.println("Daemon thread has finished.");
        } else {
            System.out.println("User thread has finished.");
        }
    }
}
```

步骤2：在主线程中创建并启动守护线程和用户线程。可以使用Thread类来创建线程对象，并将Runnable实例作为参数传递给Thread的构造函数。设置守护线程可以调用setDaemon(true)方法。

```java
public class Main {
    public static void main(String[] args) {
        // 创建守护线程
        Thread daemonThread = new Thread(new MyRunnable());
        daemonThread.setDaemon(true);

        // 创建用户线程
        Thread userThread = new Thread(new MyRunnable());

        // 启动线程
        daemonThread.start();
        userThread.start();

        // 主线程等待用户线程执行完毕
        try {
            userThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 主线程执行完毕后的代码
        System.out.println("Main thread has finished.");
    }
}
```

步骤3：运行程序，观察守护线程和用户线程的执行情况。

当运行这段代码时，会创建一个守护线程和一个用户线程。守护线程会输出"Daemon thread is running."，然后睡眠5秒钟，之后输出"Daemon thread has finished."。用户线程同样也会输出对应的信息。主线程在等待用户线程执行完毕后输出"Main thread has finished."。

总结：通过创建Runnable实例，将其传递给Thread对象并调用start()方法来创建和启动守护线程和用户线程。设置守护线程可以调用setDaemon(true)方法。主线程通过调用join()方法等待用户线程执行完毕。这样就实现了守护线程和用户线程的控制。
