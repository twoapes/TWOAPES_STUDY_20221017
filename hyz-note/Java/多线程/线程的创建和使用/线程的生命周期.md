# 线程的生命周期

JDK中用Thread.State类定义了线程的几种状态

要想实现多线程，必须在主线程中创建新的线程对象

Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态

- 新建

当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态

- 就绪

处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源

- 运行

当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能

- 阻塞

在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态

- 死亡

线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束

1.生命周期关注两个概念：状态、相应的方法
2.关注：状态a-->状态b:哪些方法执行了（回调方法）
某个方法主动调用：状态a-->状态b
3.阻塞：临时状态，不可以作为最终状态
死亡：最终状态

下面是使用Java实现多线程生命周期的示例代码和详细步骤：

步骤1：创建一个实现Runnable接口的类，并重写run()方法。这个类将作为线程的执行体。

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 线程执行的代码
        System.out.println("Thread is running.");
    }
}
```

步骤2：在主线程中创建并启动子线程。可以使用Thread类来创建线程对象，并将Runnable实例作为参数传递给Thread的构造函数。

```java
public class Main {
    public static void main(String[] args) {
        // 创建Runnable实例
        MyRunnable myRunnable = new MyRunnable();

        // 创建线程对象
        Thread thread = new Thread(myRunnable);

        // 启动线程
        thread.start();

        // 等待线程执行完毕
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 线程执行完毕后的代码
        System.out.println("Thread has finished.");
    }
}
```

步骤3：运行程序，观察多线程的生命周期。

当运行这段代码时，将会创建一个新的线程，并执行Runnable实例中的run()方法。子线程开始运行后，会输出"Thread is running."。主线程中使用`thread.join()`方法等待子线程执行完毕，然后输出"Thread has finished."。

总结：通过创建Runnable实例、将其传递给Thread对象并调用start()方法来创建和启动一个新线程。主线程通过调用join()方法等待子线程执行完毕。这样就实现了多线程的生命周期控制。
