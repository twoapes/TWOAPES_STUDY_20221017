# 如何创建多线程

方式一:使用Thread类
jdk1.5之前步骤:

1. 创建一个继承自Thread类的子类,并重写其run()方法
2. 在子类中可以添加其他的方法和成员变量来支持线程的操作
3. 创建子类的实例对象,并调用start()方法启动线程

示例代码:

```java
class MyThread extends Thread {
    public void run() {
        // 线程的执行逻辑
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start();
    }
}
```

方式二:使用Runnable接口
jdk1.5之前步骤:

1. 创建一个实现了Runnable接口的类,并实现其run()方法
2. 创建实现了Runnable接口的对象
3. 创建Thread对象,将实现了Runnable接口的对象作为参数传递给Thread的构造函数
4. 调用Thread对象的start()方法启动线程

示例代码:

```java
class MyRunnable implements Runnable {
    public void run() {
        // 线程的执行逻辑
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyRunnable runnable = new MyRunnable();
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
```

方式三:使用Callable接口
jdk1.5之后步骤:

1. 创建实现了Callable接口的类,并实现call()方法
2. 创建Callable实例对象
3. 创建ExecutorService对象,用于管理线程的执行
4. 调用ExecutorService的submit()方法,将Callable对象作为参数传递给它
5. submit()方法会返回一个Future对象,代表了线程执行的结果
6. 可以通过Future对象的get()方法获取线程的执行结果
7. 最后,当不再需要执行线程时,记得调用ExecutorService的shutdown()方法来关闭线程池

示例代码:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

class MyCallable implements Callable<String> {
    public String call() throws Exception {
        // 线程的执行逻辑
        return "Thread is running";
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        MyCallable callable = new MyCallable();

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<String> future = executor.submit(callable);

        String result = future.get();
        System.out.println(result);

        executor.shutdown();
    }
}
```

这三种方式都可以用来创建多线程,具体选择哪种方式取决于你的需求和场景
Thread类方式相对简单,但灵活性较低
Runnable接口方式更灵活,一个类可以同时实现其他接口
Callable接口方式提供了更多的控制权和获取线程执行结果的能力

>线程的优先级
>
>MIN_PRIORITY:1
>
>MAX_PRIORITY:10
>
>NORM_PRIORITY:5 默认
