# 异常处理机制二

## throws

- 声明抛出异常是Java中处理异常的第二种方式

> 如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，
而由该方法的调用者负责处理
在方法声明中用throws语句可以声明抛出异常的列表， throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类

- 声明抛出异常举例

## 重写方法声明抛出异常的原则

重写方法不能抛出比被重写方法范围更大的异常类型

在多态的情况下,对methodA()方法的调用-异常的捕获按父类声明的异常处理

## 手动抛出异常：throw

Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出

首先要生成异常类对象， 然后通过throw语句实现抛出操作

> 提交给Java运行环境

`IOException e=new IOException();
throw e;`
可以抛出的异常必须是Throwable或其子类的实例

下面的语句在编译时将会产生语法错误
`throw new String("want to throw") ;`

重写方法声明抛出异常的原则

重写方法不能抛出比被重写方法范围更大的异常类型

在多态的情况下,对method A() 方法的调用-异常的捕获按父类声明的异常处理。

以下是一个Java的throw示例：

```java
import java.util.Scanner;

public class DivideDemo {
    public static void divide(int num, int denom) throws Exception {
        if (denom == 0) {
            throw new Exception("Divide by zero exception");
        }
        System.out.println("Result: " + num / denom);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter numerator: ");
        int numerator = scanner.nextInt();
        System.out.print("Enter denominator: ");
        int denominator = scanner.nextInt();

        try {
            divide(numerator, denominator);
        } catch (Exception ex) {
            System.err.println("Exception: " + ex.getMessage());
        }
    }
}
```

在这个例子中，我们定义了一个divide方法，它接受两个整数作为参数，并在分母为零时抛出一个Exception类型的异常。我们还定义了一个try-catch块，在try块中调用divide方法，如果divide方法抛出了一个异常，我们将捕获并打印异常消息。
