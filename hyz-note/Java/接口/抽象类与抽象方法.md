# 抽象类与抽象方法

随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用

类的设计应该保证父类和子类能够共享特征

有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类

- 用abstract关键字来修饰一个类，这个类叫做**抽象类**

- 用abstract来修饰一个方法，该方法叫做**抽象方法**

- 只有方法的声明，没有方法的实现

- 含有抽象方法的类必须被声明为抽象类

- 抽象类不能被实例化,抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体

- 若没有重写全部的抽象方法，仍为抽象类

- 不能用abstract修饰变量、代码块、构造器

- 不能用abstract修饰私有方法、静态方法、final的方法、final的类。

下面是一个使用Java抽象类和抽象方法的示例：

```java
abstract class Shape {
    String color;

    public Shape(String color) {
        this.color = color;
    }

    abstract double getArea();

    public void display() {
        System.out.println("Color: " + color);
    }
}

class Circle extends Shape {
    double radius;

    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }

    public double getArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    double width, height;

    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }

    public double getArea() {
        return width * height;
    }
}

class Main {
    public static void main(String[] args) {
        Shape circle = new Circle("Red", 5.0);
        circle.display(); // 输出 Color: Red
        System.out.println("Area of Circle: " + circle.getArea()); // 输出 Area of Circle: 78.53981633974483

        Shape rectangle = new Rectangle("Blue", 10.0, 5.0);
        rectangle.display(); // 输出 Color: Blue
        System.out.println("Area of Rectangle: " + rectangle.getArea()); // 输出 Area of Rectangle: 50.0
    }
}
```

在这个示例中，我们定义了一个名为 `Shape` 的抽象类，并声明了一个抽象方法 `getArea`。我们还定义了一个名为 `Circle` 的子类和一个名为 `Rectangle` 的子类，它们都扩展了 `Shape` 抽象类并实现了 `getArea` 方法。

在 `main` 方法中，我们创建了一个 `Circle` 对象和一个 `Rectangle` 对象，并分别调用它们的 `display` 和 `getArea` 方法。由于 `Circle` 和 `Rectangle` 类都实现了 `getArea` 方法，因此它们可以用相同的方式调用。
