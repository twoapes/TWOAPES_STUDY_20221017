# 有限制的通配符

- \<?>

  允许所有泛型的引用调用

- 通配符指定上限

  上限extends

  使用时指定的类型必须是继承某个类，或者实现某个接口，即\<=

- 通配符指定下限

  下限super

  使用时指定的类型不能小于操作的类，即>=

<? extends Number> (无穷小 , Number]
只允许泛型为Number及Number子类的引用调用
<? super Number> [Number , 无穷大)
只允许泛型为Number及Number父类的引用调用
<? extends Comparable>
只允许泛型为实现Comparable接口的实现类的引用调用

以下是一个使用Java有限制的通配符的示例代码：

```java
import java.util.ArrayList;
import java.util.List;

class Animal {
    public void eat() {
        System.out.println("Animal is eating...");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking...");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Cat is meowing...");
    }
}

public class BoundedWildcardDemo {
    public static void processAnimals(List<? extends Animal> animals) {
        for (Animal animal : animals) {
            animal.eat();
        }
    }

    public static void main(String[] args) {
        List<Dog> dogs = new ArrayList<>();
        dogs.add(new Dog());
        dogs.add(new Dog());

        List<Cat> cats = new ArrayList<>();
        cats.add(new Cat());
        cats.add(new Cat());

        processAnimals(dogs);
        processAnimals(cats);
    }
}
```

在示例代码中，我们定义了一个基类`Animal`，以及两个子类`Dog`和`Cat`。`Dog`和`Cat`继承自`Animal`类，并拥有各自的方法。

然后，我们定义了一个静态方法`processAnimals`，它接受一个通配符类型为`? extends Animal`的`List`作为参数。这里的有限制通配符`? extends Animal`表示只能接受`Animal`类或其子类的列表。在方法内部，我们遍历传入的动物列表，并调用它们的`eat()`方法。

在`main`方法中，我们创建了一个`List<Dog>`对象`dogs`，并添加了两只`Dog`对象；同时，创建了一个`List<Cat>`对象`cats`，并添加了两只`Cat`对象。然后，我们分别调用`processAnimals`方法，并将`dogs`和`cats`作为参数传递进去。

运行该示例代码，将会输出以下结果：

```java
Animal is eating...
Animal is eating...
```

这说明使用有限制的通配符`? extends Animal`，我们可以在方法中接受一种动物及其子类的列表。这样可以增加方法的灵活性，同时限制了具体的类型范围。

有限制的通配符通常用于那些只读取数据的场景，因为无法确定具体子类型，所以无法添加具体子类型的对象到列表中。如果需要同时读取和写入数据，可以使用有限制的通配符`? super Animal`，它可以接受`Animal`类及其父类的列表。
