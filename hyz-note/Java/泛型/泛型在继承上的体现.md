# 泛型在继承上的体现

如果B是A的一个子类型(子类或者子接口),而G是具有泛型声明的类或接口,G\<B>并不是G\<A>的子类型!
比如

String是Object的子类, 但是List\<String>并不是List\<Object>的子类

以下是一个使用Java泛型在继承上的示例代码：

```java
class Animal {
    public void eat() {
        System.out.println("Animal is eating...");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking...");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Cat is meowing...");
    }
}

class Cage<T extends Animal> {
    private T animal;

    public Cage(T animal) {
        this.animal = animal;
    }

    public void setAnimal(T animal) {
        this.animal = animal;
    }

    public T getAnimal() {
        return animal;
    }
}

public class InheritanceWithGenericsDemo {
    public static void main(String[] args) {
        Cage<Dog> dogCage = new Cage<>(new Dog());
        dogCage.getAnimal().eat();
        dogCage.getAnimal().bark();

        Cage<Cat> catCage = new Cage<>(new Cat());
        catCage.getAnimal().eat();
        catCage.getAnimal().meow();
    }
}
```

在示例代码中，我们定义了一个基类`Animal`，以及两个子类`Dog`和`Cat`。`Dog`和`Cat`继承自`Animal`类，并拥有各自的方法。

然后，我们定义了一个泛型类`Cage<T extends Animal>`，其中泛型类型参数`T`必须是`Animal`类或其子类。`Cage`类具有一个成员变量`animal`，表示笼子中的动物，以及相应的访问器方法。

在`main`方法中，我们创建了一个`Cage<Dog>`对象`dogCage`，并将其初始化为包含一只`Dog`的笼子。然后我们通过`getAnimal()`方法获取笼子中的动物，并调用其继承自`Animal`类的方法`eat()`和独有的方法`bark()`。

接着，我们创建了一个`Cage<Cat>`对象`catCage`，并将其初始化为包含一只`Cat`的笼子。然后我们同样通过`getAnimal()`方法获取笼子中的动物，并调用其继承自`Animal`类的方法`eat()`和独有的方法`meow()`。

运行该示例代码，将会输出以下结果：

```java
Animal is eating...
Dog is barking...
Animal is eating...
Cat is meowing...
```

这说明使用Java泛型在继承上，我们可以在泛型类中限制泛型类型参数必须是某个类或其子类，从而在使用泛型类时限制类型的范围。这样可以确保在编译时类型的安全性，并且可以在泛型类中使用父类的方法和子类的特有方法。
