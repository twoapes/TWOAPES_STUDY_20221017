# 自定义泛型结构

```java
//JDK 1.5 之前
Comparable c = new Date();
System.out.println(c.compareTo("red"));
//JDK 1.5
Comparable<Date> c = new Date();
System.out.println(c.compareTo("red"));
```

体会：使用泛型的主要优点是能够在编译时而不是在运行时检测错误

## 泛型类,泛型接口

1.泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。

> 比如

`<E1,E2,E3>`

2.泛型类的构造器

> 如下

`public GenericClass(){}`
而下面是错误的

`public GenericClass<E>(){}`

3.实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致

4.泛型不同的引用不能相互赋值

尽管在编译时ArrayList\<String>和ArrayList\<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中

5.泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object

  经验

  泛型要使用一路都用

  要不用,一路都不要用

6.如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象

7.jdk1.7,泛型的简化操作

`ArrayList<Fruit> flist = new ArrayList<>();`

8.泛型的指定中不能使用基本数据类型,可以使用包装类替换

9.在类/接口上声明的泛型,在本类或本接口中即代表某种类型,可以作为非静态属性的类型,非静态方法的参数类型,非静态方法的返回值类型

但在静态方法中不能使用类的泛型

10.异常类不能是泛型的

11.不能使用new E[]

> 但是可以：E[] elements = (E[])new Object[capacity];
参考：ArrayList源码中声明

`Object[] elementData`，而非泛型参数类型数组

12.父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型

子类不保留父类的泛型

  按需实现

- 没有类型 擦除

- 具体类型

子类保留父类的泛型

  泛型子类

- 全部保留

- 部分保留

子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型

以下是一个使用Java自定义泛型结构的示例代码：

```java
public class GenericDemo<T> {
    private T value;

    public GenericDemo(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }

    public static void main(String[] args) {
        GenericDemo<String> stringDemo = new GenericDemo<>("Hello");
        System.out.println("String value: " + stringDemo.getValue());

        GenericDemo<Integer> integerDemo = new GenericDemo<>(42);
        System.out.println("Integer value: " + integerDemo.getValue());

        GenericDemo<Double> doubleDemo = new GenericDemo<>(3.14);
        System.out.println("Double value: " + doubleDemo.getValue());
    }
}
```

在示例代码中，我们创建了一个名为`GenericDemo`的泛型类。这个类使用了类型参数`T`，表示一个占位符类型，可以在实例化时指定具体的类型。

该泛型类包含一个成员变量`value`和相应的访问器方法。通过构造方法和`setValue()`方法，我们可以设置`value`的值，通过`getValue()`方法获取`value`的值。

在`main`方法中，我们分别实例化了`GenericDemo`类的三个对象：`stringDemo`、`integerDemo`和`doubleDemo`。分别使用`String`、`Integer`和`Double`类型实例化，并传入相应的值。

然后，我们分别通过`getValue()`方法获取每个对象的值，并使用`System.out.println()`方法打印出来。

运行该示例代码，将会输出以下结果：

```java
String value: Hello
Integer value: 42
Double value: 3.14
```

这说明通过自定义泛型结构，我们可以在编写代码时不确定具体类型，而在实例化对象时指定具体的类型。泛型提供了类型安全和代码复用的好处，可以用于创建通用的数据结构和算法。
