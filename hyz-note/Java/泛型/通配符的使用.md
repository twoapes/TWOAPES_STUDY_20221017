# 通配符的使用

1.使用类型通配符

```java
比如：List<?> ，Map<?,?>
List<?>是List<String>、List<Object>等各种泛型List的父类
```

2.读取List<?>的对象list中的元素时,永远是安全的,因为不管list的真实类型是什么,它包含的都是Object
3.写入list中的元素时,不行,因为我们不知道c的元素类型，我们不能向其中添加对象

```java
Collection<?> c = new ArrayList<String>();
c.add(new Object()); // 编译时错误
```

- 唯一的例外的是null，它是所有类型的成员

- 另一方面，我们可以调用get()方法并使用其返回值

- 返回值是一个未知的类型，但是我们知道，它总是一个Object

以下是一个使用Java通配符的示例代码：

```java
import java.util.ArrayList;
import java.util.List;

class Animal {
    public void eat() {
        System.out.println("Animal is eating...");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking...");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Cat is meowing...");
    }
}

public class WildcardDemo {
    public static void printAnimals(List<? extends Animal> animals) {
        for (Animal animal : animals) {
            animal.eat();
        }
    }

    public static void main(String[] args) {
        List<Dog> dogs = new ArrayList<>();
        dogs.add(new Dog());
        dogs.add(new Dog());

        List<Cat> cats = new ArrayList<>();
        cats.add(new Cat());
        cats.add(new Cat());

        printAnimals(dogs);
        printAnimals(cats);
    }
}
```

在示例代码中，我们定义了一个基类`Animal`，以及两个子类`Dog`和`Cat`。`Dog`和`Cat`继承自`Animal`类，并拥有各自的方法。

然后，我们定义了一个静态方法`printAnimals`，它接受一个泛型类型为`? extends Animal`的`List`作为参数。这里的通配符`?`表示未知的具体类型，但它必须是`Animal`类或其子类。在方法内部，我们遍历传入的动物列表，并调用它们的`eat()`方法。

在`main`方法中，我们创建了一个`List<Dog>`对象`dogs`，并添加了两只`Dog`对象；同时，创建了一个`List<Cat>`对象`cats`，并添加了两只`Cat`对象。然后，我们分别调用`printAnimals`方法，并将`dogs`和`cats`作为参数传递进去。

运行该示例代码，将会输出以下结果：

```java
Animal is eating...
Animal is eating...
```

这说明使用Java通配符`? extends Animal`，我们可以在方法中接受一种动物的列表，但不限制具体是哪个子类。这样可以使方法更加灵活，可以接受不同子类的列表作为参数。

需要注意的是，通配符`? extends Animal`只能用于读取（调用基类方法），而不能用于写入（添加具体子类对象到列表中），因为编译器无法确定具体的子类型。如果需要写入和读取，可以使用`? super Animal`通配符。
