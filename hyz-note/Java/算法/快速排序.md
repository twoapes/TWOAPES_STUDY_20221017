# 快速排序

快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性
快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种

冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为O(nlog(n))
排序思想

1. 从数列中挑出一个元素，称为"基准"（pivot），

2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后,该基准就处于数列的中间位置。这个称为分区（partition）操作。

3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

4. 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去

快速排序是一种高效的排序算法，它的基本思想是将一个大问题分解为小问题，然后递归处理这些小问题，最终将结果合并起来。它的时间复杂度为O(nlogn)，是一种非常有效的排序方法。
下面是Java实现快速排序的代码示例:

```java
public static void quickSort(int[] nums, int left, int right) {
    if (left < right) {
        int pivot = partition(nums, left, right);
        quickSort(nums, left, pivot-1);
        quickSort(nums, pivot+1, right);
    }
}

private static int partition(int[] nums, int left, int right) {
    int pivot = nums[right];
    int i = left - 1;
    for (int j = left; j <= right-1; j++) {
        if (nums[j] < pivot) {
            i++;
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
    int temp = nums[i+1];
    nums[i+1] = nums[right];
    nums[right] = temp;
    return i+1;
}
```

该方法接受一个整数数组和两个整数参数left和right，表示数组中要排序的子数组的左右边界。算法使用递归的方式对数组进行快速排序。在每次递归中，我们首先选择一个基准元素，然后使用partition方法将数组分割成两个部分，左边的元素都小于基准元素，右边的元素都大于基准元素。最后，我们递归处理左右两个子数组并将结果合并起来，得到最终的排序结果。

```java
int[] nums = {5, 2, 9, 1, 5, 6};
quickSort(nums, 0, nums.length-1);
System.out.println(Arrays.toString(nums));
```
