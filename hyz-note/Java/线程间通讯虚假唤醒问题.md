# 线程间通讯虚假唤醒问题

在线程间通信的过程中，存在一种称为"虚假唤醒"（spurious wake-up）的现象。虚假唤醒指的是在没有明确收到通知的情况下，线程从等待状态被唤醒。这可能是由于操作系统或虚拟机的内部实现问题导致的，并不代表条件已经满足。为了避免虚假唤醒，通常在等待的时候应该使用循环来检查条件是否满足

下面是一个演示虚假唤醒问题的Java示例代码：

```java
class SharedObject {
    private boolean flag = false;

    public synchronized void waitForFlag() {
        while (!flag) {
            try {
                wait(); // 线程等待
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("Flag is now true");
    }

    public synchronized void setFlag() {
        flag = true;
        notify(); // 唤醒等待的线程
    }
}

class WaitThread extends Thread {
    private SharedObject sharedObject;

    public WaitThread(SharedObject sharedObject) {
        this.sharedObject = sharedObject;
    }

    public void run() {
        sharedObject.waitForFlag();
    }
}

class SetFlagThread extends Thread {
    private SharedObject sharedObject;

    public SetFlagThread(SharedObject sharedObject) {
        this.sharedObject = sharedObject;
    }

    public void run() {
        try {
            Thread.sleep(2000); // 等待2秒钟
            sharedObject.setFlag();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class ThreadCommunicationDemo {
    public static void main(String[] args) {
        SharedObject sharedObject = new SharedObject();

        WaitThread waitThread = new WaitThread(sharedObject);
        SetFlagThread setFlagThread = new SetFlagThread(sharedObject);

        waitThread.start();
        setFlagThread.start();

        try {
            Thread.sleep(1000); // 等待1秒钟
            sharedObject.notify(); // 发送虚假唤醒信号
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

在这个示例中，除了原本的WaitThread和SetFlagThread线程，还加入了一个主线程。在主线程中，我们在等待1秒钟后调用了`sharedObject.notify()`方法，发送了一个虚假的唤醒信号。

虚假唤醒可能会导致问题，因为WaitThread在没有收到真正的通知情况下被唤醒。为了解决虚假唤醒问题，可以修改`waitForFlag()`方法，使用循环来检查条件：

```java
public synchronized void waitForFlag() {
    while (!flag) {
        try {
            wait(); // 线程等待
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    // 循环检查条件
    while (!flag) {
        try {
            wait(); // 线程等待
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }


    System.out.println("Flag is now true");
}
```

通过这种方式，即使出现虚假唤醒，线程也会再次检查条件，确保条件满足后才继续执行

需要注意的是，虚假唤醒是一个非常罕见的情况，在大多数情况下，等待和唤醒的机制是可靠的

然而，为了保证程序的正确性，应该始终使用循环来检查条件，以避免虚假唤醒可能带来的问题
