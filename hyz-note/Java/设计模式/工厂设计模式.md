# 工厂设计模式

接口的应用：工厂模式
工厂模式：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。
其实设计模式和面向对象设计原则都是为了使得开发项目更加容易扩展和维护，解决方式就是一个“分工”。

社会的发展也是这样，分工越来越细。

原始社会的人：人什么都要会，自己种，自己打猎，自己织衣服，自己治病

现在的人：可以只会一样，其他都不会，只会 Java 也能活，不会做饭，不会开车，不会....

## 工厂模式的分类

- 简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，
需要修改已有代码）

- 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品）

- 抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无
能为力；支持增加产品族）

GOF 在《设计模式》一书中将工厂模式分为两类：

工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。

将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。

核心本质：
实例化对象，用工厂方法代替 new 操作

将选择实现类、创建对象统一管理和控制

从而将调用者跟我们的实现类解耦。

1.无工厂模式

```java
public class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    @Override
    public String getName() {
        return "Dog";
    }
}

public class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }

    @Override
    public String getName() {
        return "Cat";
    }
}

public class AnimalFactory {
    public static Animal createAnimal(String name) {
        if (name.equals("dog")) {
            return new Dog(name);
        } else if (name.equals("cat")) {
            return new Cat(name);
        } else {
            return null;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal1 = AnimalFactory.createAnimal("dog");
        Animal animal2 = AnimalFactory.createAnimal("cat");
        System.out.println(animal1.getName()); // 输出：Dog
        System.out.println(animal2.getName()); // 输出：Cat
    }
}
```

2、简单工厂模式
简单工厂模式，从命名上就可以看出这个模式一定很简单。它存在的目的很简单：定义一个用于创建对象的工厂类

```java
public class AnimalFactory {
    public static Animal createAnimal(String type) {
        if (type.equals("dog")) {
            return new Dog();
        } else if (type.equals("cat")) {
            return new Cat();
        } else {
            return null;
        }
    }
}

public class Dog extends Animal {
    public Dog() {
        super("Dog");
    }

    @Override
    public String getName() {
        return "Dog";
    }
}

public class Cat extends Animal {
    public Cat() {
        super("Cat");
    }

    @Override
    public String getName() {
        return "Cat";
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal1 = AnimalFactory.createAnimal("dog");
        Animal animal2 = AnimalFactory.createAnimal("cat");
        System.out.println(animal1.getName()); // 输出：Dog
        System.out.println(animal2.getName()); // 输出：Cat
    }
}
```

调用者只要知道他要什么，从哪里拿，如何创建，不需要知道。分工，多出了一个专门生产 Car 的实现类对象的工厂类。把调用者与创建者分离。
小结：
简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的实例对象。
缺点：对于增加新产品，不修改代码的话，是无法扩展的。违反了开闭原则（对扩展开放；对修改封闭）。

3、工厂方法模式
为了避免简单工厂模式的缺点，不完全满足 OCP（对扩展开放，对修改关闭）。工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立的模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担

```java
public interface AnimalFactory {
    Animal createAnimal();
}

public class DogFactory implements AnimalFactory {
    @Override
    public Animal createAnimal() {
        return new Dog();
    }
}

public class CatFactory implements AnimalFactory {
    @Override
    public Animal createAnimal() {
        return new Cat();
    }
}

public class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public class Dog extends Animal {
    public Dog() {
        super("Dog");
    }

    @Override
    public String getName() {
        return "Dog";
    }
}

public class Cat extends Animal {
    public Cat() {
        super("Cat");
    }

    @Override
    public String getName() {
        return "Cat";
    }
}

public class Main {
    public static void main(String[] args) {
        AnimalFactory factory = new DogFactory();
        Animal animal1 = factory.createAnimal();
        System.out.println(animal1.getName()); // 输出：Dog

        factory = new CatFactory();
        Animal animal2 = factory.createAnimal();
        System.out.println(animal2.getName()); // 输出：Cat
    }
}
```

总结：
简单工厂模式与工厂方法模式真正的避免了代码的改动了？没有。在简单工厂模式中，新产品的加入要修改工厂角色中的判断语句；而在工厂方法模式中，要么将判断逻辑留在抽象工厂角色中，要么在客户程序中将具体工厂角色写死（就像上面的例子一样）。而且产品对象创建条件的改变必然会引起工厂角色的修改。
面对这种情况，Java 的反射机制与配置文件的巧妙结合突破了限制——这在Spring 中完美的体现了出来

4、抽象工厂模式
抽象工厂模式和工厂方法模式的区别就在于需要创建对象的复杂程度上。

而且抽象工厂模式是三个里面最为抽象、最具一般性的。
抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。
而且使用抽象工厂模式还要满足一下条件：

1. 系统中有多个产品族，而系统一次只可能消费其中一族产品。

2. 同属于同一个产品族的产品以其使用。看过了前两个模式，对这个模式各个角色之间的协调情况应该心里有个数了，我就不举具体的例子了

```java
public interface ProductFactory {
    Product createProduct();
}

public class ConcreteProductA implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductA is operating.");
    }
}

public class ConcreteProductB implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductB is operating.");
    }
}

public class AbstractFactory {
    public static Product createProduct(String type) {
        if (type.equals("A")) {
            return new ConcreteProductA();
        } else if (type.equals("B")) {
            return new ConcreteProductB();
        } else {
            return null;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        ProductFactory factory = new AbstractFactory();
        Product product1 = factory.createProduct("A");
        product1.operation();

        factory = new AbstractFactory();
        Product product2 = factory.createProduct("B");
        product2.operation();
    }
}
```
