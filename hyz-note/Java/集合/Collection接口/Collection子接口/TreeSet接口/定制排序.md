# 定制排序

- TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序

- 定制排序，通过Comparator接口来实现

  需要重写compare(T o1,T o2)方法

- 利用int compare(T o1,T o2)方法，比较o1和o2的大小

  如果方法返回正整数，则表示o1大于o2

  如果返回0，表示相等；返回负整数，表示o1小于o2

- 要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器

- 此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常

- 使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0

下面是一个使用TreeSet实现定制排序的详细示例代码：

```java
import java.util.Comparator;
import java.util.TreeSet;

public class TreeSetCustomSortingDemo {
    public static void main(String[] args) {
        // 创建一个TreeSet实例，并指定定制排序规则
        TreeSet<Employee> set = new TreeSet<>(new EmployeeComparator());

        // 添加元素到TreeSet
        set.add(new Employee("John", 30));
        set.add(new Employee("Alice", 25));
        set.add(new Employee("Bob", 35));
        set.add(new Employee("David", 28));
        set.add(new Employee("Carol", 32));

        System.out.println("TreeSet的大小: " + set.size()); // 输出：5

        // 遍历TreeSet
        System.out.println("TreeSet的元素:");
        for (Employee employee : set) {
            System.out.println(employee);
        }

        // 判断元素是否存在于TreeSet中
        Employee searchEmployee = new Employee("Alice", 25);
        System.out.println("TreeSet中是否包含员工" + searchEmployee + ": " + set.contains(searchEmployee)); // 输出：true

        // 从TreeSet中删除元素
        Employee removeEmployee = new Employee("Bob", 35);
        set.remove(removeEmployee);
        System.out.println("TreeSet的大小: " + set.size()); // 输出：4

        // 清空TreeSet
        set.clear();
        System.out.println("TreeSet是否为空: " + set.isEmpty()); // 输出：true
    }

    static class Employee {
        private String name;
        private int age;

        public Employee(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public int getAge() {
            return age;
        }

        @Override
        public String toString() {
            return "Employee{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }
    }

    static class EmployeeComparator implements Comparator<Employee> {
        @Override
        public int compare(Employee employee1, Employee employee2) {
            // 按照年龄进行升序排序
            return Integer.compare(employee1.getAge(), employee2.getAge());
        }
    }
}
```

以上代码创建了一个TreeSet实例，并演示了使用定制排序规则的功能。首先，定义了一个Employee类表示员工，其中包含姓名和年龄属性。然后，定义了一个EmployeeComparator类实现Comparator接口，通过比较员工的年龄进行排序。接下来，创建TreeSet实例时，传入EmployeeComparator实例，以指定定制的排序规则。然后，通过add()方法添加员工对象到TreeSet，TreeSet会根据定制的排序规则进行排序。最后，通过size()方法获取TreeSet的大小，使用增强型for循环遍历TreeSet中的元素，并使用contains()方法判断元素是否存在于TreeSet中。接下来，通过remove()方法删除TreeSet中的元素，并再次使用size()方法验证大小的变化。最后，通过clear()方法清空TreeSet，并使用isEmpty()方法判断TreeSet是否为空。

运行上述代码，将会输出以下结果：

```shell
TreeSet的大小: 5
TreeSet的元素:
Employee

{name='Alice', age=25}
Employee{name='David', age=28}
Employee{name='John', age=30}
Employee{name='Carol', age=32}
Employee{name='Bob', age=35}
TreeSet中是否包含员工Employee{name='Alice', age=25}: true
TreeSet的大小: 4
TreeSet是否为空: true
```

可以看到，TreeSet根据定制的排序规则（按照员工的年龄进行升序排序）进行排序，并且保持有序状态。其他的操作方法与HashSet和LinkedHashSet类似，可以根据需要进行添加、删除和查找操作。
