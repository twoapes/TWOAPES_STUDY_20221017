# 静态绑定和动态绑定

静态绑定（Static Binding）和动态绑定（Dynamic Binding）是面向对象编程中多态性（Polymorphism）的两种不同形式。

- 静态绑定（Static Binding）：

  - 静态绑定是在编译时确定方法或函数调用的实际实现。也称为早期绑定（Early Binding）或静态分派（Static Dispatch）。

  - 在静态绑定中，编译器根据引用变量的类型来决定要调用的方法，不考虑实际运行时对象的类型。编译器根据变量声明的静态类型进行绑定。

  - 静态绑定通常发生在非虚函数或静态方法的调用中，这些方法在编译时就可以确定其具体实现。

- 动态绑定（Dynamic Binding）：

  - 动态绑定是在运行时确定方法或函数调用的实际实现。也称为晚期绑定（Late Binding）或动态分派（Dynamic Dispatch）。

  - 在动态绑定中，方法调用的具体实现取决于实际运行时对象的类型，而不是引用变量的类型。运行时系统根据对象的实际类型进行绑定。

  - 动态绑定通常发生在虚函数或动态多态性的调用中。在这种情况下，编译器会生成一张虚函数表（vtable），通过该表在运行时查找正确的函数实现。

动态绑定实现了面向对象编程的重要特性——多态性。它允许使用基类类型的引用变量来调用派生类的方法，以实现方法的动态调度和运行时多态性。

以下是一个简单的Java示例，展示了静态绑定和动态绑定的区别：

```java
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound.");
    }
}

class Dog extends Animal {
    public void makeSound() {
        System.out.println("Dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Dog dog = new Dog();

        animal.makeSound(); // 输出: Animal makes a sound.
        dog.makeSound();    // 输出: Dog barks.

        Animal animalDog = new Dog();
        animalDog.makeSound(); // 输出: Dog barks. (动态绑定)
    }
}
```

在上面的示例中，Animal类和Dog类之间存在继承关系。通过静态绑定，使用Animal类型的引用变量调用makeSound方法时，编译器选择Animal类的实现。而使用动态绑定，通过Animal类型的引用变量调用makeSound方法时，运行时系统根据对象的实际类型选择正确的实现，即Dog类的实现。

通过动态绑定，可以实现基于继承的多态性，让程序更加灵活和可扩展。

以重载和重写为例

对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”

而对于重写，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”
